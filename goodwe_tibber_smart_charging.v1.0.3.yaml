blueprint:
  name: Tibber/GoodWe Smart Charge mit PV-Optimierung v.1.0.3
  description: Optimiert das Laden und den Export deines GoodWe Wechselrichters basierend auf Tibber-Preisen, aktueller PV-Leistung und optionaler Solarprognose.
  domain: automation
  input:
    tibber_price_data_sensor:
      name: Tibber Preisdaten Sensor
      description: Sensor, der stündliche Tibber-Preisinformationen liefert (z.B. sensor.tibber_price_data aus benutzerdefiniertem YAML).
      selector:
        entity:
          domain: sensor
    pv_power_sensor:
      name: Aktueller PV Leistungs Sensor (W)
      description: Sensor, der die aktuelle PV-Leistung deines GoodWe Wechselrichters anzeigt.
      selector:
        entity:
          domain: sensor
          device_class: power
    battery_soc_sensor:
      name: Batterie SOC Sensor (%)
      description: Sensor, der den aktuellen Ladezustand (SOC) deiner GoodWe Batterie anzeigt.
      selector:
        entity:
          domain: sensor
          device_class: battery
    goodwe_work_mode_selector:
      name: GoodWe Betriebsmodus Selector
      description: Die 'select'-Entität deines GoodWe Wechselrichters, mit der der Betriebsmodus geändert werden kann (z.B. select.goodwe_work_mode).
      selector:
        entity:
          domain: select
    goodwe_export_limit_switch:
      name: GoodWe Exportsperre Schalter
      description: Die 'switch'-Entität deines GoodWe Wechselrichters, mit der die Exportsperre aktiviert/deaktiviert werden kann (z.B. switch.goodwe_export_limit).
      selector:
        entity:
          domain: switch
    solar_forecast_sensor:
      name: Solar Prognose Sensor (Optional, W)
      description: Ein optionaler Sensor, der eine zukünftige Solarleistungsprognose liefert (z.B. von ha-solar-forecast-ml).
      default: null
      selector:
        entity:
          domain: sensor
    charge_hours:
      name: Anzahl der günstigsten Ladestunden
      description: Wie viele der günstigsten Tibber-Stunden zum Laden genutzt werden sollen.
      default: 3
      selector:
        number:
          min: 1
          max: 8
          unit_of_measurement: "Stunden"
    pv_threshold_low:
      name: PV Schwellenwert Niedrig (W)
      description: Unterhalb dieser PV-Leistung wird die Exportsperre bei Bedarf aktiviert oder das Laden aus dem Netz begonnen (z.B. 50W).
      default: 50
      selector:
        number:
          min: 0
          unit_of_measurement: "W"
    pv_threshold_high:
      name: PV Schwellenwert Hoch (W)
      description: Oberhalb dieser PV-Leistung wird die Exportsperre bei vollem Akku deaktiviert (z.B. 50W).
      default: 50
      selector:
        number:
          min: 0
          unit_of_measurement: "W"
    soc_full_threshold:
      name: Batterie SOC Voller Schwellenwert (%)
      description: Batterie Ladezustand (SOC) in %, ab dem die Batterie als "voll" gilt (z.B. 99%).
      default: 99
      selector:
        number:
          min: 1
          max: 100
          unit_of_measurement: "%"

mode: single # Verhindert, dass die Automation mehrfach gleichzeitig läuft
max_exceeded: silent # Ignoriert, wenn die Automation zu schnell ausgelöst wird

trigger:
  - platform: time_pattern # Jede Minute prüfen
    minutes: "*"
  - platform: homeassistant # Neu bewerten, wenn sich relevante Sensoren ändern
    event_type: state_changed
    entity_id:
      - !input pv_power_sensor
      - !input battery_soc_sensor
      - !input goodwe_work_mode_selector
      - !input goodwe_export_limit_switch
      - !input solar_forecast_sensor
      - !input tibber_price_data_sensor # Auch triggern, wenn Tibber-Daten aktualisiert werden

variables:
  # Eingabe-Variablen
  v_tibber_sensor: !input tibber_price_data_sensor
  v_pv_power_sensor: !input pv_power_sensor
  v_battery_soc_sensor: !input battery_soc_sensor
  v_work_mode_selector: !input goodwe_work_mode_selector
  v_export_limit_switch: !input goodwe_export_limit_switch
  v_solar_forecast_sensor: !input solar_forecast_sensor
  v_charge_hours: "{{ iif(states(v_charge_hours) is not none and states(v_charge_hours) | is_number, states(v_charge_hours) | int, 3) }}"
  v_pv_threshold_low: "{{ iif(states(v_pv_threshold_low) is not none and states(v_pv_threshold_low) | is_number, states(v_pv_threshold_low) | int, 50) }}"
  v_pv_threshold_high: "{{ iif(states(v_pv_threshold_high) is not none and states(v_pv_threshold_high) | is_number, states(v_pv_threshold_high) | int, 50) }}"
  v_soc_full_threshold: "{{ iif(states(v_soc_full_threshold) is not none and states(v_soc_full_threshold) | is_number, states(v_soc_full_threshold) | int, 99) }}"
  
  # Aktuelle Zustände
  pv_leistung: "{{ states(v_pv_power_sensor) | float(0) }}"
  batterie_soc: "{{ states(v_battery_soc_sensor) | float(100) }}"
  aktueller_modus: "{{ states(v_work_mode_selector) }}"
  export_limit_active: "{{ is_state(v_export_limit_switch, 'on') }}"
  
  # Wert des Solar-Prognose-Sensors
  solar_forecast_value: >
    {% set forecast_state = states(v_solar_forecast_sensor) %}
    {% if forecast_state is not none and forecast_state not in ['unavailable', 'unknown', 'none', 'null', ''] %}
      {{ forecast_state | float(0) }}
    {% else %}
      {{ 0 }} # Standardwert 0, wenn Sensor nicht verfügbar/konfiguriert oder Wert ungültig
    {% endif %}

  # Tibber Preisverarbeitung (nur einmal pro Minute, um Neuberechnungen zu vermeiden)
  current_time: "{{ now() }}"
  current_hour_utc: "{{ now().replace(minute=0, second=0, microsecond=0) }}"
  # Annahme: tibber_price_data_sensor hat ein Attribut mit der Struktur 'today' und 'tomorrow'
  tibber_raw_prices: "{{ state_attr(v_tibber_sensor, 'home').currentSubscription.priceInfo if state_attr(v_tibber_sensor, 'home') is not none else {} }}"


  # Kombinierte Preise für heute und morgen
  combined_prices_with_time: >
    {% set prices = [] %}
    {% set today_prices = tibber_raw_prices.today | default([]) %}
    {% set tomorrow_prices = tibber_raw_prices.tomorrow | default([]) %}
    
    {% for i in range(24) %}
      {% set price_time = current_time.replace(hour=i, minute=0, second=0, microsecond=0) %}
      {% if price_time >= current_time.replace(minute=0, second=0, microsecond=0) %} # Nur zukünftige oder aktuelle Stunden
        {% if today_prices is not none and i < today_prices | length and today_prices[i].total is not none %}
          {% set price_data = today_prices[i].total %}
          {% set success = prices.append({'time': price_time, 'price': price_data}) %}
        {% endif %}
      {% endif %}
    {% endfor %}

    {% set next_day = current_time + timedelta(days=1) %}
    {% for i in range(24) %}
      {% set price_time = next_day.replace(hour=i, minute=0, second=0, microsecond=0) %}
      {% if tomorrow_prices is not none and i < tomorrow_prices | length and tomorrow_prices[i].total is not none %}
        {% set price_data = tomorrow_prices[i].total %}
        {% set success = prices.append({'time': price_time, 'price': price_data}) %}
      {% endif %}
    {% endfor %}
    {{ prices }}

  # Die N günstigsten Stunden ermitteln
  cheapest_hours_info: >
    {% set sorted_prices = combined_prices_with_time | sort(attribute='price') %}
    {% set num_to_select = [v_charge_hours | int(3), sorted_prices | length] | min %}
    {{ sorted_prices[:num_to_select] }}

  # Prüfen, ob die aktuelle Stunde eine der günstigsten Ladestunden ist
  is_current_hour_cheap: >
    {% set current_hour_start = current_time.replace(minute=0, second=0, microsecond=0) %}
    {% set is_cheap = false %}
    {% for hour_info in cheapest_hours_info %}
      {% if hour_info.time == current_hour_start %}
        {% set is_cheap = true %}
        {% break %}
      {% endif %}
    {% endfor %}
    {{ is_cheap }}

action:
  - choose:
      # --- Szenario 1: Laden aus dem Netz (Backup-Modus) ---
      - conditions:
          - "{{ is_current_hour_cheap }}" # Ist die aktuelle Stunde eine der günstigsten?
          - "{{ batterie_soc < v_soc_full_threshold }}" # Ist der Akku noch nicht "voll"?
          - "{{ aktueller_modus != 'backup' }}" # Nur schalten, wenn nicht bereits im Backup-Modus
          - condition: or # NEUE LOGIK: Laden, wenn keine Prognose ODER Prognose niedrig ODER aktuelle PV niedrig
            conditions:
              - "{{ v_solar_forecast_sensor == 'none' }}" # Kein Solar Forecast Sensor konfiguriert
              - "{{ solar_forecast_value <= v_pv_threshold_low | float(50) }}" # Oder Solar Forecast ist niedrig
              - "{{ pv_leistung <= v_pv_threshold_low | float(50) }}" # Fallback auf aktuelle PV, wenn kein Forecast oder Forecast niedrig
        sequence:
          - service: select.select_option
            target:
              entity_id: !input goodwe_work_mode_selector
            data:
              option: "backup"
          - if:
              - "{{ export_limit_active }}" # Wenn Exportsperre aktiv ist, deaktiviere sie beim Laden aus dem Netz
            then:
              - service: switch.turn_off
                target:
                  entity_id: !input goodwe_export_limit_switch
    
      # --- Szenario 2: Normaler Betrieb (General-Modus) ---
      - conditions:
          - "{{ not is_current_hour_cheap }}" # Aktuelle Stunde ist nicht günstig zum Laden
          - "{{ aktueller_modus != 'general' }}" # Und der Wechselrichter ist nicht bereits im General-Modus
        sequence:
          - service: select.select_option
            target:
              entity_id: !input goodwe_work_mode_selector
            data:
              option: "general"
    
  - choose: # Separate "choose" für die Exportsperre, um unabhängig zu reagieren
      # --- Szenario 3: Exportsperre aktivieren (im General-Modus) ---
      - conditions:
          - "{{ aktueller_modus == 'general' }}" # Nur im General-Modus relevant
          - "{{ not export_limit_active }}" # Nur aktivieren, wenn nicht bereits aktiv
          - "{{ batterie_soc < v_soc_full_threshold }}" # Akku ist nicht voll
          - "{{ pv_leistung <= v_pv_threshold_low | float(50) }}" # Und die aktuelle PV-Leistung ist gering
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input goodwe_export_limit_switch

      # --- Szenario 4: Exportsperre deaktivieren (im General-Modus) ---
      - conditions:
          - "{{ aktueller_modus == 'general' }}" # Nur im General-Modus relevant
          - "{{ export_limit_active }}" # Nur deaktivieren, wenn bereits aktiv
          - condition: or # Deaktivieren, wenn Akku voll ODER aktuelle PV-Leistung hoch
            conditions:
              - "{{ batterie_soc >= v_soc_full_threshold }}"
              - "{{ pv_leistung > v_pv_threshold_high | float(50) }}"
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input goodwe_export_limit_switch
