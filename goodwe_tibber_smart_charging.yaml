blueprint:
  name: GoodWe & Tibber Smart Charge (v5.3 Final Fix)
  description: |
    **Intelligente Batteriesteuerung für GoodWe Wechselrichter mit Tibber**
    
    Dieses Blueprint optimiert deinen Speicher vollautomatisch, um Stromkosten zu senken und den Eigenverbrauch zu maximieren.

    **Funktionsweise:**
    1. **Günstiges Laden:** Der Akku wird in den **X günstigsten Stunden** des Tages (basierend auf Tibber-Preisen für heute & morgen) aus dem Netz geladen (Modus: Backup).
    2. **Intelligente Zurückhaltung:** Wenn für die günstigen Stunden genug **Solarstrom vorhergesagt** ist (über optionalen Forecast-Sensor) oder aktuell die Sonne scheint, wird das Netzladen übersprungen.
    3. **Export-Management:** Im Eigenverbrauchsmodus (General) wird die **Exportsperre** automatisch aktiviert, wenn der Akku entladen wird, und deaktiviert, wenn der Akku voll ist.

    **Status-Helfer:**
    Der Blueprint benötigt zwei existierende Helfer:
    * **Text-Helfer (`input_text`)**: Zeigt die Uhrzeiten der günstigsten Ladestunden an.
    * **Toggle-Helfer (`input_boolean`)**: Zeigt an, ob der Akku aktuell aus dem Netz geladen wird.

    **Voraussetzungen:**
    * **HACS GoodWe Integration**
    * **Tibber Daten-Sensor** (manuell in configuration.yaml erstellt, siehe Anleitung)

  domain: automation
  input:
    tibber_price_data_sensor:
      name: Tibber Preisdaten Sensor (Verarbeitet)
      description: >
        Der vorbereitete Template-Sensor, der die Tibber-Preisdaten als Attribut 'tibber_data' enthält
        (z.B. sensor.tibber_processed_prices aus der configuration.yaml).
      selector:
        entity:
          domain: sensor
    pv_power_sensor:
      name: Aktuelle PV-Leistung (W)
      description: Sensor für die aktuelle Erzeugung des Wechselrichters.
      selector:
        entity:
          domain: sensor
          device_class: power
    battery_soc_sensor:
      name: Batterie Ladestand (%)
      description: Sensor für den aktuellen SOC der Batterie.
      selector:
        entity:
          domain: sensor
          device_class: battery
    goodwe_work_mode_selector:
      name: GoodWe Betriebsmodus Selector
      description: >
        Die Entität zum Umschalten des Modus (z.B. select.goodwe_work_mode).
        Muss Optionen wie 'General' und 'Backup' haben.
      selector:
        entity:
          domain: select
    goodwe_export_limit_switch:
      name: GoodWe Exportsperre Schalter
      description: >
        Der Schalter zum Ein-/Ausschalten der Einspeisebegrenzung.
      selector:
        entity:
          domain: switch
    solar_forecast_sensor:
      name: Solar Prognose Sensor (Optional)
      description: >
        Ein Sensor, der die erwartete Solarleistung in Watt liefert.
      default: null
      selector:
        entity:
          domain: sensor
    charge_hours:
      name: Ladedauer in Stunden
      description: Anzahl der günstigsten Stunden, in denen geladen werden soll.
      default: 3
      selector:
        number:
          min: 1
          max: 8
          unit_of_measurement: "Stunden"
    pv_threshold_low:
      name: PV-Schwellenwert Niedrig (W)
      description: Unterhalb dieses Wertes gilt - Keine nennenswerte Sonne.
      default: 50
      selector:
        number:
          min: 0
          unit_of_measurement: "W"
    pv_threshold_high:
      name: PV-Schwellenwert Hoch (W)
      description: Oberhalb dieses Wertes gilt - Viel Überschuss.
      default: 50
      selector:
        number:
          min: 0
          unit_of_measurement: "W"
    soc_full_threshold:
      name: Batterie Voll-Schwellenwert (%)
      description: Ab diesem Ladestand gilt der Akku als voll.
      default: 99
      selector:
        number:
          min: 1
          max: 100
          unit_of_measurement: "%"
    helper_cheapest_hours_text:
      name: Text-Helfer Günstige Stunden
      description: >
        Ein input_text-Helfer, der die günstigsten Ladestunden anzeigt.
        Du musst diesen Helfer vorher in Home Assistant erstellen (Einstellungen > Geräte & Dienste > Helfer).
      selector:
        entity:
          domain: input_text
    helper_charging_from_grid_toggle:
      name: Toggle-Helfer Akku lädt aus Netz
      description: >
        Ein input_boolean-Helfer, der anzeigt, ob der Akku gerade aus dem Netz geladen wird.
        Du musst diesen Helfer vorher in Home Assistant erstellen (Einstellungen > Geräte & Dienste > Helfer).
      selector:
        entity:
          domain: input_boolean

mode: single
max_exceeded: silent

trigger:
  - platform: time_pattern
    minutes: "*"
  - platform: state
    entity_id:
      - !input pv_power_sensor
      - !input battery_soc_sensor
      - !input goodwe_work_mode_selector
      - !input goodwe_export_limit_switch
      - !input solar_forecast_sensor
      - !input tibber_price_data_sensor

variables:
  # Inputs (direkt aus dem Blueprint übergeben)
  v_tibber_sensor: !input tibber_price_data_sensor
  v_pv_power_sensor: !input pv_power_sensor
  v_battery_soc_sensor: !input battery_soc_sensor
  v_work_mode_selector: !input goodwe_work_mode_selector
  v_export_limit_switch: !input goodwe_export_limit_switch
  v_solar_forecast_sensor: !input solar_forecast_sensor
  v_helper_cheapest_hours_text: !input helper_cheapest_hours_text
  v_helper_charging_from_grid_toggle: !input helper_charging_from_grid_toggle
  
  # Aktuelle Status-Werte der Entitäten
  pv_leistung: "{{ states(v_pv_power_sensor) | float(0) }}"
  batterie_soc: "{{ states(v_battery_soc_sensor) | float(100) }}"
  aktueller_modus: "{{ states(v_work_mode_selector) }}"
  export_limit_active: "{{ is_state(v_export_limit_switch, 'on') }}"
  
  # Solar Forecast Logic
  solar_forecast_value: >
    {% set forecast_state = states(v_solar_forecast_sensor) %}
    {% if forecast_state is not none and forecast_state not in ['unavailable', 'unknown', 'none', 'null', ''] %}
      {{ forecast_state | float(0) }}
    {% else %}
      {{ 0 }}
    {% endif %}

  # Tibber Logic
  current_time: "{{ now() }}"
  tibber_raw_prices: "{{ state_attr(v_tibber_sensor, 'tibber_data') | default({'today': [], 'tomorrow': []}) }}"

  # Preise kombinieren (Heute + Morgen)
  combined_prices_with_time: >
    {% set prices = [] %}
    {% set today_prices = tibber_raw_prices.today | default([]) %}
    {% set tomorrow_prices = tibber_raw_prices.tomorrow | default([]) %}
    
    {% for i in range(24) %}
      {% set price_time = current_time.replace(hour=i, minute=0, second=0, microsecond=0) %}
      {% if price_time >= current_time.replace(minute=0, second=0, microsecond=0) %}
        {% if today_prices is not none and i < today_prices | length and today_prices[i].total is not none %}
          {% set success = prices.append({'time': price_time, 'price': today_prices[i].total}) %}
        {% endif %}
      {% endif %}
    {% endfor %}

    {% set next_day = current_time + timedelta(days=1) %}
    {% for i in range(24) %}
      {% set price_time = next_day.replace(hour=i, minute=0, second=0, microsecond=0) %}
      {% if tomorrow_prices is not none and i < tomorrow_prices | length and tomorrow_prices[i].total is not none %}
        {% set success = prices.append({'time': price_time, 'price': tomorrow_prices[i].total}) %}
      {% endif %}
    {% endfor %}
    {{ prices }}

  cheapest_hours_info: >
    {% set sorted_prices = combined_prices_with_time | sort(attribute='price') %}
    {% set num_to_select = [ (states('input_number.' ~ (input('charge_hours') | string)) | int(3)), sorted_prices | length] | min %} 
    {# KORREKTUR: Direkter Zugriff auf !input charge_hours über states() mit Default-Wert #}
    {{ sorted_prices[:num_to_select] }}

  is_current_hour_cheap: >
    {% set current_hour_start = current_time.replace(minute=0, second=0, microsecond=0) %}
    {% set is_cheap = false %}
    {% for hour_info in cheapest_hours_info %}
      {% if hour_info.time == current_hour_start %}
        {% set is_cheap = true %}
        {% break %}
      {% endif %}
    {% endfor %}
    {{ is_cheap }}

  # Formatierte Liste der günstigsten Stunden für den Text-Helfer
  formatted_cheapest_hours: >
    {% set hours_list = [] %}
    {% for hour_info in cheapest_hours_info %}
      {% set success = hours_list.append(hour_info.time.strftime('%H:%M')) %}
    {% endfor %}
    {{ hours_list | join(', ') if hours_list | length > 0 else 'N/A' }}

action:
  # Aktualisiere den Text-Helfer mit den günstigsten Stunden
  - service: input_text.set_value
    target:
      entity_id: !input helper_cheapest_hours_text
    data:
      value: "{{ formatted_cheapest_hours }}"

  - choose:
      # 1. LADEN (Backup-Modus)
      - conditions:
          - "{{ is_current_hour_cheap }}"
          - "{{ batterie_soc < (states('input_number.' ~ (input('soc_full_threshold') | string)) | float(99)) }}" 
          {# KORREKTUR: Direkter Zugriff auf !input soc_full_threshold #}
          - "{{ aktueller_modus != 'backup' }}"
          - condition: or
            conditions:
              - "{{ v_solar_forecast_sensor == 'none' or states(v_solar_forecast_sensor) in ['unavailable', 'unknown', 'none', 'null', ''] }}" # Zusätzliche Prüfung für Forecast
              - "{{ solar_forecast_value <= (states('input_number.' ~ (input('pv_threshold_low') | string)) | float(50)) }}" 
              {# KORREKTUR: Direkter Zugriff auf !input pv_threshold_low #}
              - "{{ pv_leistung <= (states('input_number.' ~ (input('pv_threshold_low') | string)) | float(50)) }}"         
              {# KORREKTUR: Direkter Zugriff auf !input pv_threshold_low #}
        sequence:
          - service: select.select_option
            target:
              entity_id: !input goodwe_work_mode_selector
            data:
              option: "backup"
          - if:
              - "{{ export_limit_active }}"
            then:
              - service: switch.turn_off
                target:
                  entity_id: !input goodwe_export_limit_switch
          - service: input_boolean.turn_on
            target:
              entity_id: !input helper_charging_from_grid_toggle
    
      # 2. NORMALBETRIEB (General-Modus)
      - conditions:
          - "{{ not is_current_hour_cheap }}"
          - "{{ aktueller_modus != 'general' }}"
        sequence:
          - service: select.select_option
            target:
              entity_id: !input goodwe_work_mode_selector
            data:
              option: "general"
          - service: input_boolean.turn_off
            target:
              entity_id: !input helper_charging_from_grid_toggle
    
  # 3. EXPORTSPERRE STEUERUNG
  - choose: 
      # A) Sperre AKTIVIEREN
      - conditions:
          - "{{ aktueller_modus == 'general' }}"
          - "{{ not export_limit_active }}"
          - "{{ batterie_soc < (states('input_number.' ~ (input('soc_full_threshold') | string)) | float(99)) }}" 
          {# KORREKTUR: Direkter Zugriff auf !input soc_full_threshold #}
          - "{{ pv_leistung <= (states('input_number.' ~ (input('pv_threshold_low') | string)) | float(50)) }}" 
          {# KORREKTUR: Direkter Zugriff auf !input pv_threshold_low #}
        sequence:
          - service: switch.turn_on
            target:
              entity_id: !input goodwe_export_limit_switch

      # B) Sperre DEAKTIVIEREN
      - conditions:
          - "{{ aktueller_modus == 'general' }}"
          - "{{ export_limit_active }}"
          - condition: or
            conditions:
              - "{{ batterie_soc >= (states('input_number.' ~ (input('soc_full_threshold') | string)) | float(99)) }}" 
              {# KORREKTUR: Direkter Zugriff auf !input soc_full_threshold #}
              - "{{ pv_leistung > (states('input_number.' ~ (input('pv_threshold_high') | string)) | float(50)) }}" 
              {# KORREKTUR: Direkter Zugriff auf !input pv_threshold_high #}
          sequence:
            - service: switch.turn_off
              target:
                entity_id: !input goodwe_export_limit_switch
